(dp1
S'output'
p2
S"<type 'exceptions.TypeError'> 'bool' object is not iterable"
p3
sS'layer'
p4
S'/home/jurgis/dev/web2py_src/applications/app/controllers/plugin_AnySQLFORM.py'
p5
sS'code'
p6
S'# -*- coding: utf-8 -*-\n\nfrom pydal.objects import Field #, Row, Expression\n\nfrom plugin_AnySQLFORM.AnySQLFORM import AnySQLFORM, FormField, get_expressions_from_formfields\nfrom plugin_AnySQLFORM.AnySQLFORM import QuerySQLFORM, SearchField\nfrom plugin_AnySQLFORM.GrandRegister import GrandRegister, DalView\nfrom plugin_AnySQLFORM.GrandRegister import GrandTranslator\n\n\n# test fields\ndef test_fields():\n    orphan_with_target = Field(\'orphan_name\')\n    orphan_with_target.target_expression = db.auth_user.last_name + "bla"\n\n    return [\n\n        db.auth_user.first_name,\n        db.auth_user.email,\n        \n        db.auth_user.id,\n        db.auth_group.role, # db.auth_group.description,\n        \n        FormField(db.auth_permission.table_name, requires = IS_IN_DB(db, db.auth_permission.table_name, multiple=True)),\n        SearchField(db.auth_permission.id),\n        \n        # no_table items   \n        Field(\'user_id\', type=\'reference auth_user\'), \n#        FormField(\'user_id\', type=\'reference auth_user\'), \n        \n        Field( \'bla\'),\n#        FormField( \'bla\'),\n#         FormField( Field( \'expr_as_value\' ), target_expression=\'string_value\' ),  # orphan field with expression in kwargs\n#         FormField( \'direct_name\', target_expression=\'direct_name_expr\' ),  #  name with expression with expression in kwargs\n#         FormField( 5, name=\'str_expr_firstarg\' ),  #  expression first -- even if it is just value\n        orphan_with_target,\n        # expression (as target)\n        FormField( db.auth_user.first_name + db.auth_user.last_name, name=\'full_name\'),\n        FormField( Field( \'pure_inputname_in_form\'), name_extension=\'\', prepend_tablename=False, target_expression=\'pure\' ),  \n    ]\n    \ndef test_queryform():\n    fields = test_fields() \n    \n    # db.auth_permission._format = "%(name)s %(table_name)s (%(id)s)"\n\n    form = QuerySQLFORM( *fields )\n    query_data = form.vars_as_Row()\n    form.check_duplicate_fields_by_attrs(\'target_expression\')\n    filter = form.build_queries()\n        \n    return dict(\n            filter = filter,\n            form=form, \n            query_data = repr(query_data),\n            # data = data,\n            vars=form.vars,\n            # vars_dict=repr(form.vars),\n            )\n    \n\n\ndef test_anyform():\n    \n    user_full_name = db.auth_user.first_name + db.auth_user.last_name\n    \n    # db.auth_permission._format = "%(name)s %(table_name)s (%(id)s)"\n    \n    fields = test_fields()\n    \n    form = AnySQLFORM( *fields )\n    # form = SQLFORM.factory( *fields )\n\n    data = form.vars_as_Row()\n        \n    return dict(\n            form=form, \n            data_dict = repr(data),\n            data = data,\n            vars=form.vars,\n            vars_dict=repr(form.vars),\n            )\n\n\ndef test_dalview_search():\n\n    fields = test_fields() \n    \n    form = QuerySQLFORM( *fields )\n\n    form.check_duplicate_fields_by_attrs(\'target_expression\')\n    filter = form.build_queries()\n    query_data = form.vars_as_Row()\n\n    cols = get_expressions_from_formfields(fields)\n    print "dbg cols", cols\n\n    selection = DalView(*cols, query=filter.query, having=filter.having,\n                  left_join_chains=[[ db.auth_user, db.auth_membership, db.auth_group, db.auth_permission ]]\n                  )\n\n    sql = selection.get_sql()\n    print( "DBG SQL: ", sql )\n\n    # data = SQLFORM.grid(search.query, fields=selected_fields, **kwargs )  # can toggle\n    data = selection.execute()\n\n    return dict(\n            sql = sql,\n            filter = filter, # query and having\n            form=form, \n            # query_data = repr(query_data),\n            data = data,\n            vars=form.vars,\n            # vars_dict=repr(form.vars),\n            )    \n\n\n# def grandform( form_factory=SQLFORM.factory ):\n\ndef test_grandregister_form_and_ajax_records(  ):\n    search_fields = test_fields()\n    cols = get_expressions_from_formfields(search_fields )\n\n    register = GrandRegister(cols,\n                             cid = \'w2ui_test\', # w2ui\n                             table_name = \'test_grand\',\n                             search_fields = [search_fields ],\n                             left_join_chains=[[ db.auth_user, db.auth_membership, db.auth_group, db.auth_permission ]]\n                             # , response_view = None\n                             )\n\n    # response.view = ...\n    if request.vars._grid:\n        response.view = "generic.json"\n\n        rows = register.w2ui_grid_records()\n\n        # return BEAUTIFY(  [ filter, rows ]  )  # for testing\n\n        if request.vars._grid_dbg:\n            def as_htmltable(rows, colnames):\n                from gluon.html import TABLE\n                return TABLE([colnames] + [[row[col] for col in colnames] for row in rows])\n            rows = as_htmltable(rows, [FormField(col).name for col in register.columns]) # for testing\n\n        # from gluon.serializers import json\n        # return json(dict(status=\'success\', records = rows ))\n        return dict(status=\'success\', records = rows )  # JSON\n\n        # return DIV( filter, register.records_w2ui() )\n        # return dict(records=register.records_w2ui())\n\n    else:\n        # response.view = "plugin_w2ui_grid/w2ui_grid.html"\n        # register.search_form.      add_button( \'grid\', URL(vars=dict(grid=True)))\n\n        result = register.form()\n\n        # for debug purposes:\n        # tablename = register.search_form.table._tablename\n        ajax_url = "javascript:ajax(\'%s\', %s, \'grid_records\'); " % (\n                                                URL(vars=dict(_grid=True, _grid_dbg=True), extension=None)  ,\n                                                [f.name for f in register.search_fields]\n                   )\n\n        ajax_link = A(\'ajax load records\', _href=ajax_url)\n        ajax_result_target = DIV( BEAUTIFY(register.records_w2ui() ), _id=\'grid_records\')\n        # register.search_form.      add_button( \'ajax load records\', ajax_url )\n        # result[\'ajax_records\']=\n        # result[\'ats\']=ajax_result_target\n\n        # register.search_form[0].insert(0, ajax_link)\n        result[\'form\'] = CAT(ajax_result_target , ajax_link, result[\'form\'] )\n\n\n        return result\n\ndef test_grandregister_render(  ):\n    search_fields = test_fields()\n    cols = get_expressions_from_formfields(search_fields )\n\n    register = GrandRegister(cols,\n                             cid = \'w2ui_test\', # w2ui\n                             table_name = \'test_grand\',\n                             search_fields = [search_fields ],\n                             left_join_chains=[[ db.auth_user, db.auth_membership, db.auth_group, db.auth_permission ]]\n                             # , response_view = None\n                             )\n    register.render()\n\ndef populate_fake_translations():\n\n    # field = db.auth_user.first_name\n    # field = db.auth_group.role\n\n    print \'dbg select\', db()._select( \'id\', field )\n    for r in db().select( \'id\', field ):\n        db.translation_field.insert(\n            tablename = field._tablename,\n            fieldname = field.name,\n            rid = r[\'id\'],\n            language_id = 2,\n            value = "EN_"+r[field]\n        )\n\n\ndef test_grandtranslator_expressions():\n\n    gt = GrandTranslator(\n        fields = [db.auth_user.first_name,   db.auth_group.role],   # we want to get tranlations only for first_name and role\n        language_id=2\n    )\n\n    tests = [\n        db.auth_user.first_name,  # Field\n        db.auth_user.first_name + db.auth_user.last_name, # Flat Expression - 1 tranlsation\n        db.auth_user.first_name + db.auth_group.role, # Flat Expression - 2 translations\n        db.auth_user.first_name.contains(\'s\'),  # Flat Query\n        # Alias ?\n\n        # structured / hierarchical / complex cases\n        (db.auth_group.role+(db.auth_user.first_name + db.auth_user.last_name)), # complex Expression\n        (db.auth_user.first_name.contains(\'s\') | (db.auth_user.first_name=="John") ) & (db.auth_user.last_name=="BLA"),  # complex Query\n\n        ]\n\n    def repr_t(t):  return map(str, [t.expr]+t.left  )\n\n    results =  [ {expr: repr_t( gt.translate( expr ))}  for expr in tests]\n    return dict(tests=results)\n\ndef test_grandtranslator_dalview():\n\n    expr = db.auth_user.first_name + db.auth_user.last_name\n    left = []\n\n    gt = GrandTranslator(\n        fields = [db.auth_user.first_name,   db.auth_group.role],   # we want to get tranlations only for first_name and role\n        language_id=2\n    )\n    translated = gt.translate(expr)\n    expr = translated.expr\n    left.extend( translated.left )\n\n    selection = DalView( expr ,  query=db.auth_user,\n                  left = left\n                  )\n\n    return dict(\n        sql = selection.get_sql(),\n        data = selection.execute()\n    )\n\ndef test_grandtranslator_dalview_search():\n\n    fields = test_fields()[:4]\n\n\n    gt = GrandTranslator(\n        fields = [db.auth_user.first_name,   db.auth_group.role],   # we want to get tranlations only for first_name and role\n        language_id=2\n    )\n\n    form = QuerySQLFORM(*fields)     # TODO decorate with translations: IS_IN_DB values..\n\n    # form.check_duplicate_fields_by_attrs(\'target_expression\')\n    filter = form.build_queries()\n    query_data = form.vars_as_Row()\n\n    cols = get_expressions_from_formfields(fields)\n    print "dbg cols", cols\n\n\n\n    tleft = []\n    def translate(expressions):\n        texpressions = []\n        for expr in expressions:\n            translated = gt.translate(expr)\n            texpressions.append(translated.expr)\n            tleft.extend(translated.left)\n        return texpressions\n\n    tfields = translate(fields)\n    tquery  = translate(filter.query)\n    thaving = translate(filter.having)\n\n    selection = DalView(*tfields, query=tquery, having=thaving,\n                        left = list(set(tleft)),\n                        left_join_chains=[[db.auth_user, db.auth_membership, db.auth_group, db.auth_permission]]\n                        )\n\n    sql = selection.get_sql()\n    print("DBG SQL: ", sql)\n\n    # data = SQLFORM.grid(search.query, fields=selected_fields, **kwargs )  # can toggle\n    data = selection.execute()\n\n    return dict(\n        sql=sql,\n        filter=filter,  # query and having\n        form=form,\n        # query_data = repr(query_data),\n        data=data,\n        vars=form.vars,\n        # vars_dict=repr(form.vars),\n    )\n\n    # selection = DalView( expr ,  query=db.auth_user,\n    #               left = left\n    #               )\n    # return dict(\n    #     sql = selection.get_sql(),\n    #     data = selection.execute()\n    # )\nresponse._vars=response._caller(test_grandtranslator_dalview_search)\n'
p7
sS'snapshot'
p8
(dp9
sS'traceback'
p10
S'Traceback (most recent call last):\n  File "/home/jurgis/dev/web2py_src/gluon/restricted.py", line 227, in restricted\n    exec ccode in environment\n  File "/home/jurgis/dev/web2py_src/applications/app/controllers/plugin_AnySQLFORM.py", line 317, in <module>\n  File "/home/jurgis/dev/web2py_src/gluon/globals.py", line 417, in <lambda>\n    self._caller = lambda f: f()\n  File "/home/jurgis/dev/web2py_src/applications/app/controllers/plugin_AnySQLFORM.py", line 286, in test_grandtranslator_dalview_search\n    tquery  = translate(filter.query)\n  File "/home/jurgis/dev/web2py_src/applications/app/controllers/plugin_AnySQLFORM.py", line 279, in translate\n    for expr in expressions:\nTypeError: \'bool\' object is not iterable\n'
p11
s.